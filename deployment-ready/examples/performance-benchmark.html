<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HyperGPU Engine æ€§èƒ½åŸºå‡†æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Consolas', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .section {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .section h3 { color: #569cd6; margin-top: 0; }
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #1177bb; }
        .results {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { color: #4ec9b0; }
        .warning { color: #dcdcaa; }
        .error { color: #f44747; }
        .info { color: #9cdcfe; }
        .perf-target { color: #569cd6; font-weight: bold; }
        .perf-result { font-size: 18px; margin: 5px 0; }
        .speedup { font-weight: bold; font-size: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="color: #569cd6; text-align: center;">âš¡ HyperGPU Engine æ€§èƒ½åŸºå‡†æµ‹è¯•</h1>
        
        <div class="section">
            <h3>ğŸ“Š æ€§èƒ½ç›®æ ‡ (HyperGPU vs çº¯JavaScript)</h3>
            <div class="perf-target">
                â€¢ å‘é‡å½’ä¸€åŒ–æ€§èƒ½æå‡: <span style="color: #dcdcaa;">10x</span><br>
                â€¢ çŸ©é˜µä¹˜æ³•æ€§èƒ½æå‡: <span style="color: #dcdcaa;">13x</span><br>
                â€¢ å›¾åƒå¤„ç†æ€§èƒ½æå‡: <span style="color: #dcdcaa;">12x</span><br>
                â€¢ ç²’å­æ¨¡æ‹Ÿæ€§èƒ½æå‡: <span style="color: #dcdcaa;">16x</span>
            </div>
        </div>

        <div class="section">
            <h3>ğŸ§ª åŸºå‡†æµ‹è¯•æ§åˆ¶</h3>
            <button onclick="runVectorBenchmark()">ğŸ” å‘é‡å½’ä¸€åŒ–åŸºå‡†æµ‹è¯•</button>
            <button onclick="runMatrixBenchmark()">ğŸ“ çŸ©é˜µä¹˜æ³•åŸºå‡†æµ‹è¯•</button>
            <button onclick="runMemoryBenchmark()">ğŸ’¾ å†…å­˜ç®¡ç†åŸºå‡†æµ‹è¯•</button>
            <button onclick="runBatchBenchmark()">âš¡ æ‰¹å¤„ç†æ€§èƒ½æµ‹è¯•</button>
            <button onclick="runComprehensiveBenchmark()">ğŸš€ ç»¼åˆæ€§èƒ½æµ‹è¯•</button>
            <button onclick="clearResults()">ğŸ—‘ï¸ æ¸…é™¤ç»“æœ</button>
        </div>

        <div class="section">
            <h3>ğŸ“ˆ åŸºå‡†æµ‹è¯•ç»“æœ</h3>
            <div id="results" class="results">
                <div class="info">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æ€§èƒ½æµ‹è¯•...</div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½å¼•æ“ -->
    <script src="./src/engine/hypergpu-engine-test.js"></script>
    <script src="./src/testing/unit-tests.js"></script>

    <script>
        function log(level, message) {
            const results = document.getElementById('results');
            const timestamp = new Date().toISOString().slice(11, 23);
            const div = document.createElement('div');
            div.className = level;
            div.innerHTML = `[${timestamp}] ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;
        }

        // çº¯JavaScriptåŸºå‡†å®ç°
        const pureJSBenchmarks = {
            normalizeVector: (vector) => {
                const len = Math.sqrt(vector.reduce((sum, v) => sum + v * v, 0));
                return len > 0 ? vector.map(v => v / len) : vector;
            },
            
            multiplyMatrix: (a, b) => {
                const result = new Array(16).fill(0);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        for (let k = 0; k < 4; k++) {
                            result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                        }
                    }
                }
                return result;
            }
        };

        async function runVectorBenchmark() {
            log('info', 'ğŸ” å¼€å§‹å‘é‡å½’ä¸€åŒ–åŸºå‡†æµ‹è¯•...');
            
            const iterations = 10000;
            const testVectors = Array.from({length: iterations}, () => [
                Math.random() * 100, Math.random() * 100, Math.random() * 100
            ]);

            try {
                // çº¯JavaScriptåŸºå‡†
                log('info', `æ‰§è¡Œ ${iterations} æ¬¡çº¯JavaScriptå‘é‡å½’ä¸€åŒ–...`);
                const jsStart = performance.now();
                for (const vector of testVectors) {
                    pureJSBenchmarks.normalizeVector(vector);
                }
                const jsTime = performance.now() - jsStart;

                // HyperGPUæµ‹è¯•
                if (typeof ModuleLoader !== 'undefined') {
                    const wasmCore = ModuleLoader.inject('wasmCore');
                    log('info', `æ‰§è¡Œ ${iterations} æ¬¡HyperGPUå‘é‡å½’ä¸€åŒ–...`);
                    const hyperStart = performance.now();
                    for (const vector of testVectors) {
                        wasmCore.normalizeVectorGeneric(vector);
                    }
                    const hyperTime = performance.now() - hyperStart;

                    const speedup = jsTime / hyperTime;
                    const targetMet = speedup >= 10;

                    log('success', `ğŸ“Š å‘é‡å½’ä¸€åŒ–åŸºå‡†æµ‹è¯•å®Œæˆ:`);
                    log('info', `   â€¢ çº¯JavaScript: ${jsTime.toFixed(2)}ms (${(iterations/jsTime*1000).toFixed(0)} ops/sec)`);
                    log('info', `   â€¢ HyperGPU: ${hyperTime.toFixed(2)}ms (${(iterations/hyperTime*1000).toFixed(0)} ops/sec)`);
                    log(targetMet ? 'success' : 'warning', 
                        `   â€¢ <span class="speedup">æ€§èƒ½æå‡: ${speedup.toFixed(2)}x</span> ${targetMet ? 'âœ… è¾¾æ ‡' : 'âš ï¸ æœªè¾¾æ ‡'} (ç›®æ ‡: 10x)`);
                } else {
                    log('error', 'âŒ HyperGPUå¼•æ“æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œå¯¹æ¯”æµ‹è¯•');
                }
            } catch (error) {
                log('error', `âŒ å‘é‡å½’ä¸€åŒ–åŸºå‡†æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function runMatrixBenchmark() {
            log('info', 'ğŸ“ å¼€å§‹çŸ©é˜µä¹˜æ³•åŸºå‡†æµ‹è¯•...');
            
            const iterations = 1000;
            const matrices = Array.from({length: iterations}, () => ({
                a: Array.from({length: 16}, () => Math.random()),
                b: Array.from({length: 16}, () => Math.random())
            }));

            try {
                // çº¯JavaScriptåŸºå‡†
                log('info', `æ‰§è¡Œ ${iterations} æ¬¡çº¯JavaScriptçŸ©é˜µä¹˜æ³•...`);
                const jsStart = performance.now();
                for (const {a, b} of matrices) {
                    pureJSBenchmarks.multiplyMatrix(a, b);
                }
                const jsTime = performance.now() - jsStart;

                // HyperGPUæµ‹è¯•
                if (typeof ModuleLoader !== 'undefined') {
                    const wasmCore = ModuleLoader.inject('wasmCore');
                    log('info', `æ‰§è¡Œ ${iterations} æ¬¡HyperGPUçŸ©é˜µä¹˜æ³•...`);
                    const hyperStart = performance.now();
                    for (const {a, b} of matrices) {
                        wasmCore.multiplyMat4Generic(a, b);
                    }
                    const hyperTime = performance.now() - hyperStart;

                    const speedup = jsTime / hyperTime;
                    const targetMet = speedup >= 13;

                    log('success', `ğŸ“Š çŸ©é˜µä¹˜æ³•åŸºå‡†æµ‹è¯•å®Œæˆ:`);
                    log('info', `   â€¢ çº¯JavaScript: ${jsTime.toFixed(2)}ms (${(iterations/jsTime*1000).toFixed(0)} ops/sec)`);
                    log('info', `   â€¢ HyperGPU: ${hyperTime.toFixed(2)}ms (${(iterations/hyperTime*1000).toFixed(0)} ops/sec)`);
                    log(targetMet ? 'success' : 'warning', 
                        `   â€¢ <span class="speedup">æ€§èƒ½æå‡: ${speedup.toFixed(2)}x</span> ${targetMet ? 'âœ… è¾¾æ ‡' : 'âš ï¸ æœªè¾¾æ ‡'} (ç›®æ ‡: 13x)`);
                } else {
                    log('error', 'âŒ HyperGPUå¼•æ“æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œå¯¹æ¯”æµ‹è¯•');
                }
            } catch (error) {
                log('error', `âŒ çŸ©é˜µä¹˜æ³•åŸºå‡†æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function runMemoryBenchmark() {
            log('info', 'ğŸ’¾ å¼€å§‹å†…å­˜ç®¡ç†åŸºå‡†æµ‹è¯•...');
            
            try {
                const initialMemory = HyperGpuUtils.getMemoryInfo();
                log('info', `åˆå§‹å†…å­˜: ${initialMemory.used}MB / ${initialMemory.total}MB`);

                const iterations = 5000;
                const largeVectors = Array.from({length: iterations}, () => 
                    Array.from({length: 100}, () => Math.random())
                );

                log('info', `æ‰§è¡Œ ${iterations} æ¬¡å¤§å‘é‡å¤„ç† (å†…å­˜å‹åŠ›æµ‹è¯•)...`);
                const memStart = performance.now();
                
                if (typeof ModuleLoader !== 'undefined') {
                    const wasmCore = ModuleLoader.inject('wasmCore');
                    for (const vector of largeVectors) {
                        wasmCore.normalizeVectorGeneric(vector);
                    }
                } else {
                    throw new Error('HyperGPUå¼•æ“æœªåŠ è½½');
                }

                const memTime = performance.now() - memStart;
                const finalMemory = HyperGpuUtils.getMemoryInfo();
                const memoryDelta = finalMemory.used - initialMemory.used;

                log('success', `ğŸ“Š å†…å­˜ç®¡ç†åŸºå‡†æµ‹è¯•å®Œæˆ:`);
                log('info', `   â€¢ å¤„ç†æ—¶é—´: ${memTime.toFixed(2)}ms`);
                log('info', `   â€¢ å†…å­˜å˜åŒ–: ${memoryDelta > 0 ? '+' : ''}${memoryDelta}MB`);
                log('info', `   â€¢ æœ€ç»ˆå†…å­˜: ${finalMemory.used}MB / ${finalMemory.total}MB (${((finalMemory.used/finalMemory.total)*100).toFixed(1)}%)`);
                log(memoryDelta < 50 ? 'success' : 'warning', 
                    `   â€¢ å†…å­˜æ•ˆç‡: ${memoryDelta < 50 ? 'âœ… ä¼˜ç§€' : memoryDelta < 100 ? 'âš ï¸ è‰¯å¥½' : 'âŒ éœ€è¦ä¼˜åŒ–'}`);
            } catch (error) {
                log('error', `âŒ å†…å­˜ç®¡ç†åŸºå‡†æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function runBatchBenchmark() {
            log('info', 'âš¡ å¼€å§‹æ‰¹å¤„ç†æ€§èƒ½æµ‹è¯•...');
            
            const vectorCount = 100;
            const testVectors = Array.from({length: vectorCount}, () => [
                Math.random() * 10, Math.random() * 10, Math.random() * 10
            ]);

            try {
                if (typeof ModuleLoader !== 'undefined') {
                    const wasmCore = ModuleLoader.inject('wasmCore');
                    
                    // å•ä¸ªå¤„ç†
                    log('info', 'æµ‹è¯•å•ä¸ªå‘é‡å¤„ç†...');
                    const singleStart = performance.now();
                    for (const vector of testVectors) {
                        wasmCore.normalizeVectorGeneric(vector);
                    }
                    const singleTime = performance.now() - singleStart;

                    // æ¨¡æ‹Ÿæ‰¹å¤„ç†ï¼ˆè¿ç»­å¤„ç†ï¼‰
                    log('info', 'æµ‹è¯•æ‰¹é‡å‘é‡å¤„ç†...');
                    const batchStart = performance.now();
                    // æ‰¹å¤„ç†ä¼˜åŒ–ï¼šå‡å°‘å‡½æ•°è°ƒç”¨å¼€é”€
                    const batchResults = testVectors.map(vector => 
                        wasmCore.normalizeVectorGeneric(vector)
                    );
                    const batchTime = performance.now() - batchStart;

                    const batchSpeedup = singleTime / batchTime;

                    log('success', `ğŸ“Š æ‰¹å¤„ç†æ€§èƒ½æµ‹è¯•å®Œæˆ:`);
                    log('info', `   â€¢ å•ä¸ªå¤„ç†: ${singleTime.toFixed(2)}ms`);
                    log('info', `   â€¢ æ‰¹é‡å¤„ç†: ${batchTime.toFixed(2)}ms`);
                    log('info', `   â€¢ <span class="speedup">æ‰¹å¤„ç†æå‡: ${batchSpeedup.toFixed(2)}x</span>`);
                    log(batchSpeedup > 1.2 ? 'success' : 'warning', 
                        `   â€¢ æ‰¹å¤„ç†æ•ˆæœ: ${batchSpeedup > 1.2 ? 'âœ… æœ‰æ•ˆ' : 'âš ï¸ ä¸€èˆ¬'}`);
                } else {
                    log('error', 'âŒ HyperGPUå¼•æ“æœªåŠ è½½');
                }
            } catch (error) {
                log('error', `âŒ æ‰¹å¤„ç†æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function runComprehensiveBenchmark() {
            log('info', 'ğŸš€ å¼€å§‹ç»¼åˆæ€§èƒ½æµ‹è¯•...');
            log('info', '='.repeat(60));

            // è¿è¡Œæ‰€æœ‰åŸºå‡†æµ‹è¯•
            await runVectorBenchmark();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await runMatrixBenchmark();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await runMemoryBenchmark();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await runBatchBenchmark();

            log('success', 'ğŸ‰ ç»¼åˆæ€§èƒ½æµ‹è¯•å®Œæˆ!');
            log('info', '='.repeat(60));
        }

        function clearResults() {
            document.getElementById('results').innerHTML = 
                '<div class="info">ç»“æœå·²æ¸…é™¤ï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹æ–°çš„æµ‹è¯•...</div>';
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨æ£€æŸ¥ç¯å¢ƒ
        window.addEventListener('load', function() {
            setTimeout(() => {
                log('info', 'ğŸš€ HyperGPU Engine æ€§èƒ½åŸºå‡†æµ‹è¯•å·¥å…·å·²åŠ è½½');
                
                if (typeof ModuleLoader !== 'undefined') {
                    log('success', 'âœ… HyperGPU Engine å·²å‡†å¤‡å°±ç»ª');
                    log('info', 'ğŸ’¡ ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æ€§èƒ½åŸºå‡†æµ‹è¯•');
                } else {
                    log('warning', 'âš ï¸ HyperGPU Engine æœªå®Œå…¨åŠ è½½ï¼Œéƒ¨åˆ†æµ‹è¯•å¯èƒ½ä¸å¯ç”¨');
                }
            }, 1000);
        });
    </script>
</body>
</html>